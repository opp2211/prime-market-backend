create extension if not exists pgcrypto;

create table user_account_txs
(
    id              bigint PRIMARY KEY generated by default as identity,
    public_id       uuid           not null default gen_random_uuid(),
    user_account_id bigint         not null references user_accounts (id),
    amount          decimal(13, 4) not null,
    type            text           not null,
    ref_type        text           not null,
    ref_id          bigint         not null,

    created_at      timestamptz    not null default now()
);

create unique index if not exists ux_user_account_txs_public_id
    on user_account_txs (public_id);

create or replace function fn_user_account_txs_apply_balance()
    returns trigger
    language plpgsql
as $$
begin
    update user_accounts
    set balance = balance + new.amount
    where id = new.user_account_id;

    return new;
end;
$$;

create trigger trg_user_account_txs_apply_balance
    after insert on user_account_txs
    for each row
execute function fn_user_account_txs_apply_balance();

create or replace function fn_user_account_txs_block_mutation()
    returns trigger
    language plpgsql
as $$
begin
    if tg_op = 'UPDATE' then
        if new.id <> old.id
            or new.public_id <> old.public_id
            or new.user_account_id <> old.user_account_id
            or new.amount <> old.amount then
            raise exception 'Updating id, public_id, user_account_id, or amount is not allowed for user_account_txs';
        end if;

        return new;
    end if;

    if tg_op = 'DELETE' then
        raise exception 'Deleting rows from user_account_txs is not allowed';
    end if;

    return null;
end;
$$;

create trigger trg_user_account_txs_block_update
    before update on user_account_txs
    for each row
execute function fn_user_account_txs_block_mutation();

create trigger trg_user_account_txs_block_delete
    before delete on user_account_txs
    for each row
execute function fn_user_account_txs_block_mutation();
